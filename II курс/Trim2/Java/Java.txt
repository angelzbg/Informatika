* Java е хибриден език за програмиране.


**** Разлика меду композиция и наследяване:
Възможен отговор 1:
 - При композицията новият клас може да бъде съставен от други типове обекти, необходими за постигане на желата функционалност, като освен това можем да ги променяме по време на изпълнение за промяна на динамичното поведение на програмите, докато при наследяването тази гъвкавост я няма, понеже компилаторът поставя ограничения по време на компилиране за класовете, създадени чрез наследяване. Преди да използваме наследяване, първо можем да помислим за композицията при създаване на нови класове, тъй като е по-просто и по-гъвкаво.

Възможен отговор 2:
 - При композицията използваме обекти от съществуващи класове в новия клас, като функционалността на съществуващия код се използва многократно, докато при наследяването новият клас се създава като тип на съществуващ клас, като добавяме към него код, без да променяме съществуващия клас.

Призовавам Тъмнен Магьосник #3:
 - При композиция в новия клас използваме обекти от съществуващи класове, които са необходими за постигане на желаното поведение, като функционалността на съществуващия код се използва многократно - можем да я променяме по време на изпълнение. Докато при наследяването тази гъвкавост я няма - новият клас се създава като тип на съществуващ клас, към който добавяме код, без да променяме съществуващия клас.
Извод: Композицията е по-проста и по-гъвкава. По-добре е първо да обмислим вариант с композиция, преди да прибегнем до наследяване. В много случаи се използват едновременно.

Призовавам Синеок Бял Дракон #4:
 - Обикновено композицията се използва когато искаме да включим възможностите на съществуващ клас в новия, но не и неговия интерфейс, докато при наследяването създаваме тип на съществуващ клас, който специализираме за някаква конкретна необходимост.


**** В един пакет се намират класовете A,B,C,Z,X,Y. Една програма има следната структура на наследяване: A<-B<-C. Освен това класът C използва два член-обекта от класовете Z и Y. Обяснете инициализирането на конструктора на C.
 - Компилаторът ще ни накара да направим конструктор на C, който задължително на първо място да извиква конструктора на базовия клас B, чийто конструктор пък ще извика конструктора на базовия си клас A.
Т.е. първо ще се изпълни конструктора на А, след това останалото от конструктора на B и след това останалата част от конструктора на C, а двата член-обекта Z и Y могат да бъдат достъпени от конструктора на C.


* Какво е "преобразуване нагоре" ? 
 - При наследяването един обект може да се използва като свой собствен тип или като обект на базовия тип.


* Не е вярно че:
 - final референция не означава, че не може да се променя реферираният от нея обект


* Взаимоотношението на конструкторите по подразбиране в една наследена архитектура е следното:
 - при активиране конструкторът на един наследен клас автоматично извиква конструктора на непосредствения родител като първи оператор.


** Ранно и късно свързване:
 - Ранно: при императивните езици, извършва се преди стартиране на програмата, програмата за свързване или компилатора пробразува обръщението към функцията в абсолютен адрес на кода, който трябва да се изпълни.
 - Късно (динамично): при обектно-ориентираните езици, извършва се по време на изпълнение на програмата, Java използва специален код, който изчислява адреса на тялото на функцията, използвайки информация, съхранявана в самия обект.

 *** Полиморфизмът е познат като късно(динамично) свързване (по подразбиране в Java). Това свързване се осъществява по време на изпълнение. То става автоматично. Базира се на типа на обекта. Полиморфното извикване на методи позволява един тип да се разграничи от друг ако и двата типа наследяват един и същ клас(базов тип). Т.е. позволява ни да пишем кода спрямо базовия клас.
Изключения: final и static методи.

 ! Методите на обекти изискват инстанции, преди да бъдат извикани, използват късно свързване. Методите на класове не изискват инстанции, използват ранно свързване.


**** Има ли вътрешен клас достъп до данни на външен клас?
Отговор:
 - Един вътрешен клас има автоматичен достъп до членовете на прилежащия външен клас. Обект от вътрешен клас може да бъде създаден само във връзка с обект от прилежащия виншен клас. Обектите от обикновените вътрешни класове неявно поддържат референции към обекти от заобикалящите класове. Изключение прави само статичен вътрешен клас.


* Възможно ли е да се предефинира вътрешен клас?
 - Да


**** Какво е контролна рамка чрез вътрешния клас?
 - Вътрешните класове се използват за реализиране на различните видове action(). Те предпазват приложението от това да стане неудобно за работа и поддръжка. Позволяват в рамките на самостоятелен клас да имаме множество наследени версии на Event. За всеки тъп действие се наследява нов Event вътрешен клас, а контролният код се записва вътре в action().


* Възможности за реализиране на традиционната форма на идентификация на типове:
 - преобразуване надолу, използване на обекти от тип Class, използване на instanceOf


* Кое от следните твърдения е вярно?
 - всеки път, когато създаваме и компилираме нов клас, се създава съответен обект от Class


* Клас, интерфейс или метод се нарича генетичен ако:
 - работи с параметър за тип


* Кога се използва unboxing и outboxing?
 - при необходимост от референтен тип искаме да работим с примитивни типове.


* 