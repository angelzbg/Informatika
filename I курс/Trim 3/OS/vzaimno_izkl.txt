

C = 5

c++				c--

LDA C	5		LDB C  	5

INC A 	6		DEC B  	4
--------
STA C			STB C
			C6

LDA C
INC A
STA C

LoadA C		LoadB C
INCA		DECB
StoreA C	StoreB C





============================================================================
взаимно изключване на два процеса:
----------------------------------------------------------------------------

вариант 1
program взаимно_изключване;
var ред_на: integer;

procedure процес_1;          procedure процес_2;
begin                        begin
  repeat                       repeat  
    ...                          ... 
    while ред_на <> 1 do;        while ред_на <> 2 do;
    критична_секция;             критична_секция; 
    ред_на := 2;                 ред_на := 1;
    ...                          ...
  until false;                 until false;
end;                         end;

begin
  ред_на := 1;
  parbegin процес_1; процес_2; parend;
end.

вариант 2
procedure процес_1;          procedure процес_2;
begin                        begin
  repeat                       repeat  
    ...                          ... 
    while ред_на_2 do;           while ред_на_1 do;
    ред_на_1 := true;            ред_на_2 := true;
    критична_секция;             критична_секция; 
    ред_на_1 := false;           ред_на_2 := false;
    ...                          ...
  until false;                 until false;
end;                         end;

вариант 3
procedure процес_1;          procedure процес_2;
begin                        begin
  repeat                       repeat  
    ...                          ... 
    ред_на_1 := true;            ред_на_2 := true;
    while ред_на_2 do;           while ред_на_1 do;
    критична_секция;             критична_секция; 
    ред_на_1 := false;           ред_на_2 := false;
    ...                          ...
  until false;                 until false;
end;                         end;

вариант 4
procedure процес_1;          procedure процес_2;
begin                        begin
  repeat                       repeat  
    ...                          ... 
    ред_на_1 := true;           ред_на_2 := true;
    while ред_на_2 do           while ред_на_1 do
      begin                        begin
        ред_на_1 := false;           ред_на_2 := false;
        случайна_задръжка;           случайна_задръжка;    
        ред_на_1 := true;            ред_на_2 := true;
      end;                         end;
    критична_секция;             критична_секция; 
    ред_на_1 := false;           ред_на_2 := false;
    ...                          ...
  until false;                 until false;
end;                         end;

вариант 5
procedure процес_1;          procedure процес_2;
begin                        begin
  repeat                       repeat  
    ...                          ... 
    ред_на_1 := true;           ред_на_2 := true;
    процес_номер := 2;          процес_номер := 1;
    while (ред_на_2 and         while (ред_на_1 and
      процес_номер = 2) do;       процес_номер = 1) do;
    критична_секция;            критична_секция; 
    ред_на_1 := false;          ред_на_2 := false;
    ...                          ...
  until false;                 until false;
end;                         end;


============================================================================
Взаимно изключване на n процеса:
----------------------------------------------------------------------------

var 
  избор: array[0..n-1] of boolean;
  номер: array[0..n-1] of integer;
...
repeat
  ...
  избор[i] := true;
  номер[i] := max(номер[0],...,номер[n-1])+1;
  избор[i] := false;
  for j := 0 to n-1 do
    begin
      while избор[j] do;
      while номер[j] <> 0 and (номер[j],j) < (номер[i],i) do;
    end;
  критична секция;
  номер[i] = 0;
  ...
until false;
...


============================================================================
взаимно изключване с машинна команда TS:
----------------------------------------------------------------------------
TS(a,b): a:=b; b:=true;
swap(a,b):

var обща: boolean;
procedure процес_1;
var локална_1: boolean;
begin
  repeat
    ...
    локална_1 := true;
    while локална_1 do TS(локална_1, обща);
    критична секция;
    обща := false;
    ...
  until false;
end;

============================================================================
семафори

P(s): while s=0 do ; s:=s-1;
V(s): s:=s+1;

P(s): while wait do TS(wait,s);
V(s): s:=false;

P(блкр1);
критична секция;
V(блкр1);

down, up

P(s)		P(q)
P(q)		P(s)
...		...
V(s)		V(q)
V(q)		V(s)

============================================================================
реализация на семафори с блокиране на процес:
----------------------------------------------------------------------------

type 
  semaphore = record
    стойност: integer;
    опашка: queue;
  end;

procedure P(var сем: semaphore);
begin
  if сем.стойност = 1 then 
    сем.стойност := 0
  else
    begin
      извикващия процес се блокира и се записва в сем.опашка;
      избор на следващ процес за изпълнение;    
    end;
end;

procedure V(var сем: semaphore);
begin
  if сем.опашка не е празна then
    деблокиране на процес от сем.опашка
  else
    сем.стойност := 1;
end;
***@@@
============================================================================
Синхронизация на процеси. Събития

wait(събитие);
signal(събитие);

reset(събитие);


============================================================================
реализация на събития с блокиране на процес:
----------------------------------------------------------------------------

type
  event = record
    статус: boolean;
    опашка: queue;
  end;

procedure wait(var e: event);
begin
  if e.статус then 
    exit
  else
    begin
      извикващия процес се блокира и се записва в е.опашка;
      избор на следващ процес за изпълнение;    
    end;
end;

procedure signal(var е: event);
begin
  е.статус := true;
  if е.опашка не е празна then
    деблокиране на всички процеси от сем.опашка
end;


============================================================================
програма производител/потребител със събития:
----------------------------------------------------------------------------

program производител_потребител;
var 
  буфер: TBuffer;
  запълнен_буфер, прочетен_буфер: event;

procedure производител;
var буф: TBuffer;
begin
    ...
    производство на данни в буф;
    буфер := буф;
    signal(запълнен_буфер);
    wait(прочетен_буфер);
    reset(прочетен_буфер);
    ...
end;

procedure потребител;
var буф: TBuffer;
begin
    ...
    wait(запълнен_буфер);
    буф := буфер;
    reset(запълнен_буфер);
    signal(прочетен_буфер);
    потребление на данни от буф;
    ...
end;

begin
  reset(запълнен_буфер);
  reset(прочетен_буфер);
  parbegin
    производител;
    потребител;
  parend;
end.
    

============================================================================
програма производител/потребител със семафори:
----------------------------------------------------------------------------

program производител_потребител;
var 
  буфер: TBuffer;
  пълен, празен: semaphore;

procedure производител;
var буф: TBuffer;
begin
  производство на данни в буф;
  P(празен);
  буфер := буф;
  V(пълен);
end;

procedure потребител;
var буф: TBuffer;
begin
  P(пълен);
  буф := буфер;
  V(празен);
  потребление на данни от буф;
end;
    
============================================================================
безкраен буфер със семафори:
----------------------------------------------------------------------------

var
  буфер: array of TBuffer; 
  брой: integer; {брой елементи в буфер}

procedure производител;
var буф: TBuffer;
begin
  ...
  производство на данни в буф;
  P(взаимно_изключване);
  буфер <= буф; {добавяме буф във буфер}
  V(взаимно_изключване);
  V(брой);
  ...
end;

procedure потребител;
var буф: TBuffer;
begin
  ...
  P(брой);
  P(взаимно_изключване);
  буф <= буфер; {взимаме един елемент от буфер}
  V(взаимно_изключване);
  потребление на данни от буф;
  ...
end;


============================================================================
краен буфер със семафори:
----------------------------------------------------------------------------

var
  буфер: array of TBuffer; 
  пълен: integer; {брой елементи в буфер}
  празен: integer; {брой свободни елементи в буфер}

procedure производител;
var буф: TBuffer;
begin
  ...
  производство на данни в буф;
  P(празен);
  P(взаимно_изключване);
  буфер <= буф; {добавяме буф във буфер}
  V(взаимно_изключване);
  V(пълен);
  ...
end;

procedure потребител;
var буф: TBuffer;
begin
  ...
  P(пълен);
  P(взаимно_изключване);
  буф <= буфер; {взимаме един елемент от буфер}
  V(взаимно_изключване);
  V(празен); 
  потребление на данни от буф;
  ...
end;

begin
  init(пълен, 0);
  init(празен, макс.размер на буфер);
  parbegin
    while true do производител;
    while true do потребител;
  parend;
end.


============================================================================
програма читатели и писатели със семафори:
----------------------------------------------------------------------------

program читатели_писатели;
var
  брой_читатели: integer;
  взаимно_изключване, запис: semaphore;

procedure читател;
begin
  repeat
    P(взаимно_изключване);
    брой_читатели := брой_читатели + 1;
    { ако някой пише, първият читател чака, иначе забранява писането и продължава }
    if брой_читатели = 1 then P(запис);
    V(взаимно_изключване);

    четене;

    P(взаимно_изключване);
    брой_читатели := брой_читатели - 1;
    { последният читател дава възможност да се пише }
    if брой_читатели = 0 then V(запис);
    V(взаимно_изключване);
  until false;
end;

procedure писател;
begin
  repeat
    P(запис);
    запис на данни;
    V(запис);
  until false;
end;

begin
  init(взаимно_изключване,1);
  init(запис,1);
  брой_читатели := 0;
  parbegin
    читател;
    писател;
  parend;
end;  


============================================================================
обядващи философи с региони:
----------------------------------------------------------------------------

var вилици: shared array[0..4] of 0..2;

procedure философ(i: 0..4);
begin
  отляво := (i-1) mod 5;
  отдясно := (i+1) mod 5;
  repeat
    мисли;
    region вилици do
      begin
        await вилици(i) = 2;
        вилици(отляво)  := вилици(отляво) - 1;
        вилици(отдясно) := вилици(отдясно) - 1;
      end;
    яде;
    region вилици do
      begin
        вилици(отляво)  := вилици(отляво) + 1;
        вилици(отдясно) := вилици(отдясно) + 1;
      end;
  until false;    
end;

обядващи философи със семафори:
----------------------------------------------------------------------------
var вилици: array[0..4] of semaphore;

procedure философ(i: 0..4);
begin
  repeat
    мисли;
    P(вилици[i]);
    P(вилици[(i+1) mod 5]);
    яде;
    V(вилици[i]);
    V(вилици[(i+1) mod 5]);  
  until false;    
end;


============================================================================
разпределение на ресурси с монитори:
----------------------------------------------------------------------------

type разпределение_на_ресурси = monitor;
var
  зает: boolean;
  свободен: condition;

procedure entry заемане_на_ресурс;
begin
  if зает then wait(свободен);
  зает := true;
end;

procedure entry освобождаване_на_ресурс;
begin
  зает := false;
  signal(свободен);
end;

begin
  зает := false;
end;  

...
var 
  ресурс1: разпределение_на_ресурси; 
begin
  ...
  ресурс1.заемане_на_ресурс;
  използваме ресурс1;
  ресурс1.освобождаване_на_ресурс; 
  ...
end;


============================================================================
програма читатели и писатели с монитори:
----------------------------------------------------------------------------

type читатели_писатели = monitor;
var
  читатели: integer;
  някой_пише: boolean;
  четене_разрешено, писане_разрешено: condition;

procedure entry начало_на_четене;
begin
  if някой_пише or not empty (опашка писане_разрешено) then wait(четене_разрешено);
  читатели := читатели + 1;
  signal(четене_разрешено);
end;

procedure entry край_на_четене;
begin
  читатели := читатели - 1;
  if читатели = 0 then signal(писане_разрешено);
end;

procedure entry начало_на_писане;
begin
  if читатели > 0 or някой_пише then wait(писане_разрешено);
  някой_пише := true;
end;

procedure entry край_на_писане;
begin
  някой_пише := false;
  if not empty (опашка четене_разрешено) then
    signal(четене_разрешено)
  else
    signal(писане_разрешено);
end;

begin
  читатели := 0;
  някой_пише := false;
end.  


send(получател, съобщ.);
receive(подател, съобщ.);




===========================================================================
остатък = заявен заем - получен заем
наличност = капитал - сума от заеми

  з п о
А 8 4 4
Б 3 2 1   А 8 4 4
В 9 2 7   В 9 2 7   В 9 2 7

нал. 2    нал. 4    нал. 8    нал. 10

  з п о
А 8 4 4   А 8 4 4
Б 3 2 1   Б 3 2 1   А 8 4 4
В 9 2 7   В 9 3 6   В 9 3 6

нал. 2    нал. 1    нал. 3



